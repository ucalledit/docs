{
  "openapi": "3.1.0",
  "info": {
    "title": "Totalis Parlay RFQ API",
    "description": "API for the Totalis Parlay RFQ system — a decentralized request-for-quote marketplace for parlay bets on Kalshi prediction markets, with on-chain Solana escrow settlement.",
    "version": "1.0.0"
  },
  "servers": [
    {
      "url": "https://api.totalis.com",
      "description": "Production"
    },
    {
      "url": "http://localhost:3000",
      "description": "Local development"
    }
  ],
  "security": [
    {
      "bearerAuth": []
    },
    {
      "apiKeyAuth": []
    }
  ],
  "tags": [
    { "name": "RFQs", "description": "User-facing endpoints for creating and managing RFQs (Requests for Quote)" },
    { "name": "Market Maker", "description": "Market maker endpoints for quoting and confirming trades" },
    { "name": "Markets", "description": "Cached Kalshi market data" },
    { "name": "User", "description": "User profile, API keys, and wallet management" },
    { "name": "Admin", "description": "Administrative API key management" },
    { "name": "Status", "description": "System health and sync observability" }
  ],
  "paths": {
    "/rfqs": {
      "post": {
        "operationId": "createRfq",
        "summary": "Create RFQ",
        "description": "Create a new Request for Quote (parlay bet request) with 2-5 legs. Each leg references a Kalshi market ticker and a side (yes/no). The system validates markets against cached and live Kalshi data, checks USDC balance, and broadcasts the RFQ to market makers via WebSocket.",
        "tags": ["RFQs"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateRFQRequest"
              },
              "example": {
                "legs": [
                  { "kalshi_market_ticker": "KXBTC-25FEB07-T100000", "side": "yes" },
                  { "kalshi_market_ticker": "KXETH-25FEB07-T3500", "side": "no" }
                ],
                "bet_amount": 100,
                "expires_in_seconds": 300
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "RFQ created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ParlayTicket"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request, market validation failed, or insufficient balance",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiError"
                },
                "examples": {
                  "invalid_request": {
                    "value": { "error": { "code": "INVALID_REQUEST", "message": "bet_amount must be between 1 and 10000" } }
                  },
                  "invalid_legs": {
                    "value": { "error": { "code": "INVALID_LEGS", "message": "Market validation failed — KXBTC-25FEB07-T100000: Market not found", "details": { "leg_errors": [{ "index": 0, "ticker": "KXBTC-25FEB07-T100000", "code": "MARKET_NOT_FOUND", "message": "Market not found" }] } } }
                  },
                  "insufficient_balance": {
                    "value": { "error": { "code": "INSUFFICIENT_BALANCE", "message": "Insufficient USDC balance. Required: 100, Available: 50", "details": { "wallet_address": "...", "required_usdc": 100, "available_usdc": 50 } } }
                  }
                }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      },
      "get": {
        "operationId": "listRfqs",
        "summary": "List RFQs",
        "description": "List the authenticated user's RFQs, optionally filtered by status.",
        "tags": ["RFQs"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "status",
            "in": "query",
            "description": "Filter by RFQ status",
            "schema": {
              "$ref": "#/components/schemas/RFQStatus"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return",
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 1,
              "maximum": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of RFQs",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "rfqs": {
                      "type": "array",
                      "items": { "$ref": "#/components/schemas/ParlayTicket" }
                    },
                    "cursor": {
                      "type": "string",
                      "nullable": true,
                      "description": "Pagination cursor (reserved for future use)"
                    }
                  }
                }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/rfqs/{id}": {
      "get": {
        "operationId": "getRfq",
        "summary": "Get RFQ",
        "description": "Get detailed information about a specific RFQ, including all quotes. Auto-expires the RFQ if past its expiration time.",
        "tags": ["RFQs"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "RFQ UUID",
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "RFQ details with quotes",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    { "$ref": "#/components/schemas/ParlayTicket" },
                    {
                      "type": "object",
                      "properties": {
                        "quotes": {
                          "type": "array",
                          "items": { "$ref": "#/components/schemas/Quote" }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "403": { "$ref": "#/components/responses/Forbidden" },
          "404": { "$ref": "#/components/responses/NotFound" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      },
      "delete": {
        "operationId": "cancelRfq",
        "summary": "Cancel RFQ",
        "description": "Cancel an open or quoted RFQ. Cannot cancel RFQs that are already accepted, confirmed, executed, or cancelled.",
        "tags": ["RFQs"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "RFQ UUID",
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "reason": {
                    "type": "string",
                    "description": "Cancellation reason"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "204": { "description": "RFQ cancelled successfully" },
          "400": {
            "description": "Cannot cancel RFQ in current status",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "403": { "$ref": "#/components/responses/Forbidden" },
          "404": { "$ref": "#/components/responses/NotFound" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/rfqs/{id}/quotes": {
      "get": {
        "operationId": "listRfqQuotes",
        "summary": "List RFQ Quotes",
        "description": "List all quotes for a specific RFQ, sorted by payout odds descending (best odds first).",
        "tags": ["RFQs"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "RFQ UUID",
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "List of quotes sorted by payout odds",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "quotes": {
                      "type": "array",
                      "items": { "$ref": "#/components/schemas/Quote" }
                    }
                  }
                }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "403": { "$ref": "#/components/responses/Forbidden" },
          "404": { "$ref": "#/components/responses/NotFound" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/rfqs/{id}/quotes/{quoteId}/accept": {
      "put": {
        "operationId": "acceptQuote",
        "summary": "Accept Quote",
        "description": "Accept a quote on an RFQ. This rejects all other pending quotes, sets a 60-second confirmation deadline for the market maker, and broadcasts the acceptance via WebSocket.",
        "tags": ["RFQs"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "RFQ UUID",
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "quoteId",
            "in": "path",
            "required": true,
            "description": "Quote UUID",
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Quote accepted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptQuoteResponse"
                }
              }
            }
          },
          "400": {
            "description": "RFQ expired or quote expired",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "403": { "$ref": "#/components/responses/Forbidden" },
          "404": { "$ref": "#/components/responses/NotFound" },
          "409": {
            "description": "RFQ or quote in invalid state for acceptance",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/mm/rfqs": {
      "get": {
        "operationId": "listOpenRfqs",
        "summary": "List Open RFQs",
        "description": "List open RFQs available for quoting. Automatically filters out expired RFQs. Supports filtering by event ticker and bet amount range.",
        "tags": ["Market Maker"],
        "security": [{ "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "event_ticker",
            "in": "query",
            "description": "Filter by Kalshi event ticker (matches any leg)",
            "schema": { "type": "string" }
          },
          {
            "name": "min_bet",
            "in": "query",
            "description": "Minimum bet amount filter",
            "schema": { "type": "number", "default": 0 }
          },
          {
            "name": "max_bet",
            "in": "query",
            "description": "Maximum bet amount filter",
            "schema": { "type": "number", "default": 999999 }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results",
            "schema": { "type": "integer", "default": 50 }
          }
        ],
        "responses": {
          "200": {
            "description": "List of open RFQs",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "rfqs": {
                      "type": "array",
                      "items": { "$ref": "#/components/schemas/ParlayTicket" }
                    }
                  }
                }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/mm/quotes": {
      "post": {
        "operationId": "submitQuote",
        "summary": "Submit Quote",
        "description": "Submit a quote for an open RFQ. The payout odds determine the total payout to the user if they win. The market maker's risk (mm_payout) is calculated as `total_payout - bet_amount`. Each MM can only have one pending quote per RFQ.",
        "tags": ["Market Maker"],
        "security": [{ "apiKeyAuth": [] }],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateQuoteRequest"
              },
              "example": {
                "rfq_id": "550e8400-e29b-41d4-a716-446655440000",
                "payout_odds": 4.0,
                "valid_for_seconds": 60,
                "leg_prices": [
                  { "leg_id": "leg-uuid-1", "odds": 2.0 },
                  { "leg_id": "leg-uuid-2", "odds": 2.0 }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Quote submitted successfully",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/Quote" }
              }
            }
          },
          "400": {
            "description": "Invalid request, RFQ expired, or insufficient balance",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "404": { "$ref": "#/components/responses/NotFound" },
          "409": {
            "description": "Already have a pending quote for this RFQ",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      },
      "get": {
        "operationId": "listMmQuotes",
        "summary": "List MM Quotes",
        "description": "List the authenticated market maker's quotes, optionally filtered by status or RFQ ID.",
        "tags": ["Market Maker"],
        "security": [{ "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "status",
            "in": "query",
            "description": "Filter by quote status",
            "schema": { "$ref": "#/components/schemas/QuoteStatus" }
          },
          {
            "name": "rfq_id",
            "in": "query",
            "description": "Filter by RFQ ID",
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results",
            "schema": { "type": "integer", "default": 50 }
          }
        ],
        "responses": {
          "200": {
            "description": "List of quotes",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "quotes": {
                      "type": "array",
                      "items": { "$ref": "#/components/schemas/Quote" }
                    }
                  }
                }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/mm/quotes/{quoteId}/confirm": {
      "put": {
        "operationId": "confirmQuote",
        "summary": "Confirm Quote",
        "description": "Confirm an accepted quote, triggering the on-chain escrow flow. This creates the Solana escrow PDA, deposits the user's stake, and deposits the market maker's risk. The escrow has a configurable deadline (default 1 hour) after which it can be auto-cancelled.",
        "tags": ["Market Maker"],
        "security": [{ "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "quoteId",
            "in": "path",
            "required": true,
            "description": "Quote UUID",
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Quote confirmed, escrow execution started",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfirmQuoteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Quote not in accepted state",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "403": { "$ref": "#/components/responses/Forbidden" },
          "404": { "$ref": "#/components/responses/NotFound" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/markets": {
      "get": {
        "operationId": "listMarkets",
        "summary": "List Markets",
        "description": "List cached Kalshi markets from whitelisted series. Markets are synced from Kalshi every 5 minutes. Filter by category (e.g., Crypto, Politics).",
        "tags": ["Markets"],
        "parameters": [
          {
            "name": "category",
            "in": "query",
            "description": "Filter by market category. Use `all` or omit to return all categories.",
            "schema": { "type": "string", "default": "all" },
            "examples": {
              "all": { "value": "all", "summary": "All categories" },
              "crypto": { "value": "Crypto", "summary": "Crypto markets" }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of cached markets",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "markets": {
                      "type": "array",
                      "items": { "$ref": "#/components/schemas/CachedMarket" }
                    },
                    "total": {
                      "type": "integer",
                      "description": "Total number of markets returned"
                    },
                    "category": {
                      "type": "string",
                      "description": "Category filter applied"
                    }
                  }
                }
              }
            }
          },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/user/me": {
      "get": {
        "operationId": "getUserProfile",
        "summary": "Get Profile",
        "description": "Get the authenticated user's profile. Auto-creates a user record on first call if one doesn't exist, using the Privy ID and optional query parameters for wallet address and email.",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "wallet_address",
            "in": "query",
            "description": "Wallet address for auto-creation (first call only)",
            "schema": { "type": "string" }
          },
          {
            "name": "email",
            "in": "query",
            "description": "Email for auto-creation (first call only)",
            "schema": { "type": "string", "format": "email" }
          }
        ],
        "responses": {
          "200": {
            "description": "User profile",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/UserProfile" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/user/username": {
      "put": {
        "operationId": "updateUsername",
        "summary": "Update Username",
        "description": "Change the authenticated user's username. Must be 3-20 characters, alphanumeric and underscores only. Cannot be in wallet address format (0x...).",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": ["username"],
                "properties": {
                  "username": {
                    "type": "string",
                    "pattern": "^[a-zA-Z0-9_]{3,20}$",
                    "description": "New username (3-20 chars, alphanumeric + underscores)"
                  }
                }
              },
              "example": { "username": "trader_123" }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Username updated",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "username": { "type": "string" }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid username format",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "404": { "$ref": "#/components/responses/NotFound" },
          "409": {
            "description": "Username already taken",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/user/username/check": {
      "get": {
        "operationId": "checkUsername",
        "summary": "Check Username",
        "description": "Check if a username is available. Username must match the format: 3-20 characters, alphanumeric and underscores only.",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "username",
            "in": "query",
            "required": true,
            "description": "Username to check",
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "description": "Username availability result",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "available": { "type": "boolean" }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid username format",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/user/api-keys": {
      "post": {
        "operationId": "createUserApiKey",
        "summary": "Create API Key",
        "description": "Generate a new API key for the authenticated user. The full key is only returned once — save it securely.",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "requestBody": {
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Optional friendly name for the API key"
                  }
                }
              },
              "example": { "name": "My Trading Bot" }
            }
          }
        },
        "responses": {
          "201": {
            "description": "API key created",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/CreatedApiKey" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      },
      "get": {
        "operationId": "listUserApiKeys",
        "summary": "List API Keys",
        "description": "List all API keys belonging to the authenticated user. Key hashes are never returned.",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "responses": {
          "200": {
            "description": "List of API keys",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "keys": {
                      "type": "array",
                      "items": { "$ref": "#/components/schemas/ApiKeyInfo" }
                    }
                  }
                }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/user/api-keys/{prefix}": {
      "delete": {
        "operationId": "revokeUserApiKey",
        "summary": "Revoke API Key",
        "description": "Revoke one of the authenticated user's API keys by its prefix. The key will immediately stop working.",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "parameters": [
          {
            "name": "prefix",
            "in": "path",
            "required": true,
            "description": "API key prefix (e.g., `api_live_abc`)",
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "204": { "description": "API key revoked" },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "403": { "$ref": "#/components/responses/Forbidden" },
          "404": { "$ref": "#/components/responses/NotFound" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/user/wallet": {
      "get": {
        "operationId": "getWallet",
        "summary": "Get Wallet",
        "description": "Get the user's embedded Privy wallet address and current SOL/USDC balances.",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "responses": {
          "200": {
            "description": "Wallet address and balances",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/WalletBalances" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/user/wallet/airdrop": {
      "post": {
        "operationId": "airdropSol",
        "summary": "Airdrop SOL",
        "description": "Airdrop devnet SOL to the user's embedded wallet. Only works on devnet. Amount must be between 0 and 2 SOL.",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "requestBody": {
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "amount": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 2,
                    "default": 1,
                    "description": "Amount of SOL to airdrop"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Airdrop successful",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "signature": { "type": "string", "description": "Solana transaction signature" },
                    "amount": { "type": "number" },
                    "wallet_address": { "type": "string" }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid amount",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/user/wallet/airdrop-usdc": {
      "post": {
        "operationId": "airdropUsdc",
        "summary": "Airdrop USDC",
        "description": "Mint devnet USDC to the user's embedded wallet. Only works on devnet. Amount must be between 1 and 1000 USDC.",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "requestBody": {
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "amount": {
                    "type": "number",
                    "minimum": 1,
                    "maximum": 1000,
                    "default": 100,
                    "description": "Amount of USDC to mint"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "USDC airdrop successful",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "signature": { "type": "string", "description": "Solana transaction signature" },
                    "amount": { "type": "number" },
                    "wallet_address": { "type": "string" }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid amount",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/user/wallet/blockhash": {
      "get": {
        "operationId": "getBlockhash",
        "summary": "Get Blockhash",
        "description": "Proxy endpoint to get the latest Solana blockhash. Useful for browser clients that don't have direct RPC access.",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "responses": {
          "200": {
            "description": "Latest blockhash",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "blockhash": { "type": "string" },
                    "lastValidBlockHeight": { "type": "integer" }
                  }
                }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/user/wallet/submit-tx": {
      "post": {
        "operationId": "submitTransaction",
        "summary": "Submit Transaction",
        "description": "Proxy endpoint to submit a signed Solana transaction. The transaction must be serialized as base64. Useful for browser clients that don't have direct RPC access.",
        "tags": ["User"],
        "security": [{ "bearerAuth": [] }, { "apiKeyAuth": [] }],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": ["signed_transaction"],
                "properties": {
                  "signed_transaction": {
                    "type": "string",
                    "description": "Base64-encoded signed Solana transaction"
                  }
                }
              },
              "example": { "signed_transaction": "AQAAAA..." }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transaction submitted and confirmed",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "signature": { "type": "string", "description": "Solana transaction signature" }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid transaction data",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/admin/api-keys": {
      "post": {
        "operationId": "adminCreateApiKey",
        "summary": "Create API Key",
        "description": "Create a new API key for any entity. Requires the `x-admin-api-key` header.",
        "tags": ["Admin"],
        "security": [{ "adminKeyAuth": [] }],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": ["entity_id"],
                "properties": {
                  "entity_id": {
                    "type": "string",
                    "description": "ID of the entity to create a key for"
                  },
                  "entity_type": {
                    "type": "string",
                    "enum": ["unified"],
                    "default": "unified",
                    "description": "Entity type (only `unified` is supported)"
                  },
                  "name": {
                    "type": "string",
                    "description": "Optional friendly name"
                  },
                  "environment": {
                    "type": "string",
                    "enum": ["live", "test"],
                    "default": "live",
                    "description": "Key environment"
                  },
                  "expires_in_days": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Optional expiration in days"
                  }
                }
              },
              "example": {
                "entity_id": "did:privy:abc123",
                "name": "Market Maker Bot",
                "environment": "live"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "API key created",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/AdminCreatedApiKey" }
              }
            }
          },
          "400": {
            "description": "Invalid request",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiError" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      },
      "get": {
        "operationId": "adminListApiKeys",
        "summary": "List API Keys",
        "description": "List all API keys, optionally filtered by entity ID or entity type.",
        "tags": ["Admin"],
        "security": [{ "adminKeyAuth": [] }],
        "parameters": [
          {
            "name": "entity_id",
            "in": "query",
            "description": "Filter by entity ID",
            "schema": { "type": "string" }
          },
          {
            "name": "entity_type",
            "in": "query",
            "description": "Filter by entity type",
            "schema": { "type": "string", "enum": ["unified"] }
          }
        ],
        "responses": {
          "200": {
            "description": "List of API keys",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "keys": {
                      "type": "array",
                      "items": { "$ref": "#/components/schemas/AdminApiKeyInfo" }
                    }
                  }
                }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/admin/api-keys/{prefix}": {
      "get": {
        "operationId": "adminGetApiKey",
        "summary": "Get API Key",
        "description": "Get detailed information about an API key by its prefix.",
        "tags": ["Admin"],
        "security": [{ "adminKeyAuth": [] }],
        "parameters": [
          {
            "name": "prefix",
            "in": "path",
            "required": true,
            "description": "API key prefix",
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "description": "API key details",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/AdminApiKeyInfo" }
              }
            }
          },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "404": { "$ref": "#/components/responses/NotFound" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      },
      "delete": {
        "operationId": "adminRevokeApiKey",
        "summary": "Revoke API Key",
        "description": "Revoke an API key by its prefix. Optionally provide a reason.",
        "tags": ["Admin"],
        "security": [{ "adminKeyAuth": [] }],
        "parameters": [
          {
            "name": "prefix",
            "in": "path",
            "required": true,
            "description": "API key prefix",
            "schema": { "type": "string" }
          }
        ],
        "requestBody": {
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "reason": {
                    "type": "string",
                    "description": "Reason for revocation"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "204": { "description": "API key revoked" },
          "401": { "$ref": "#/components/responses/Unauthorized" },
          "404": { "$ref": "#/components/responses/NotFound" },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    },
    "/status": {
      "get": {
        "operationId": "getStatus",
        "summary": "System Health",
        "description": "Get system health status including RFQ/quote/escrow statistics, market cache info, sync status, and WebSocket connection counts.",
        "tags": ["Status"],
        "responses": {
          "200": {
            "description": "System health information",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HealthStatus" }
              }
            }
          },
          "500": {
            "description": "System unhealthy",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": { "type": "string", "enum": ["unhealthy"] },
                    "version": { "type": "string" },
                    "timestamp": { "type": "string", "format": "date-time" },
                    "error": { "type": "string" }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/status/sync": {
      "get": {
        "operationId": "getSyncStatus",
        "summary": "Sync Status",
        "description": "Get detailed market sync observability data including recent sync logs.",
        "tags": ["Status"],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of sync logs to return (max 200)",
            "schema": { "type": "integer", "default": 50, "maximum": 200 }
          }
        ],
        "responses": {
          "200": {
            "description": "Sync status and logs",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "running": { "type": "boolean" },
                    "last_run": {
                      "type": "object",
                      "nullable": true,
                      "properties": {
                        "started_at": { "type": "string", "format": "date-time" },
                        "completed_at": { "type": "string", "format": "date-time" },
                        "duration_ms": { "type": "integer" },
                        "series_succeeded": { "type": "integer" },
                        "series_failed": { "type": "integer" },
                        "total_markets_synced": { "type": "integer" }
                      }
                    },
                    "recent_logs": {
                      "type": "array",
                      "items": { "$ref": "#/components/schemas/SyncLog" }
                    }
                  }
                }
              }
            }
          },
          "500": { "$ref": "#/components/responses/InternalError" }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "bearerAuth": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT",
        "description": "Privy JWT token. Use `Authorization: Bearer <token>`. Supported for REST API only."
      },
      "apiKeyAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "UCALLEDIT_API_KEY",
        "description": "API key for programmatic access. Format: `api_live_xxxxxxxxxxxxxxxxxxxxx`. Supported for REST API and WebSocket."
      },
      "adminKeyAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "x-admin-api-key",
        "description": "Admin API key for administrative operations."
      }
    },
    "schemas": {
      "RFQStatus": {
        "type": "string",
        "enum": ["open", "quoted", "accepted", "confirmed", "executed", "cancelled", "expired"],
        "description": "Lifecycle status of an RFQ"
      },
      "QuoteStatus": {
        "type": "string",
        "enum": ["pending", "accepted", "confirmed", "executed", "rejected", "expired", "withdrawn"],
        "description": "Lifecycle status of a quote"
      },
      "EscrowStatus": {
        "type": "string",
        "enum": ["created", "user_funded", "active", "settled_win", "settled_loss", "cancelled"],
        "description": "On-chain escrow status"
      },
      "Side": {
        "type": "string",
        "enum": ["yes", "no"],
        "description": "Bet side"
      },
      "ParlayLeg": {
        "type": "object",
        "required": ["id", "kalshi_event_ticker", "kalshi_market_ticker", "side"],
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "kalshi_event_ticker": { "type": "string", "description": "Kalshi event ticker" },
          "kalshi_market_ticker": { "type": "string", "description": "Kalshi market ticker" },
          "side": { "$ref": "#/components/schemas/Side" },
          "event_title": { "type": "string", "description": "Human-readable event title" },
          "market_title": { "type": "string", "description": "Human-readable market title" },
          "current_yes_price": { "type": "number", "description": "Current yes price (0-1)" },
          "current_no_price": { "type": "number", "description": "Current no price (0-1)" }
        }
      },
      "ParlayTicket": {
        "type": "object",
        "required": ["id", "user_id", "legs", "status", "created_at", "expires_at", "bet_amount"],
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "user_id": { "type": "string" },
          "legs": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/ParlayLeg" },
            "minItems": 2,
            "maxItems": 5
          },
          "status": { "$ref": "#/components/schemas/RFQStatus" },
          "created_at": { "type": "string", "format": "date-time" },
          "expires_at": { "type": "string", "format": "date-time" },
          "bet_amount": { "type": "number", "minimum": 1, "maximum": 10000 },
          "implied_probability": { "type": "number", "description": "Combined implied probability of all legs" },
          "accepted_quote_id": { "type": "string", "format": "uuid", "nullable": true },
          "cancellation_reason": { "type": "string", "nullable": true },
          "escrow_pda": { "type": "string", "nullable": true, "description": "Solana escrow PDA address" },
          "escrow_status": { "$ref": "#/components/schemas/EscrowStatus" }
        }
      },
      "Quote": {
        "type": "object",
        "required": ["id", "parlay_ticket_id", "market_maker_id", "payout_odds", "total_cost", "total_payout", "mm_payout", "valid_until", "status", "created_at", "updated_at"],
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "parlay_ticket_id": { "type": "string", "format": "uuid" },
          "market_maker_id": { "type": "string" },
          "payout_odds": { "type": "number", "minimum": 1.01, "maximum": 1000, "description": "Multiplier applied to bet_amount for total payout" },
          "total_cost": { "type": "number", "description": "User's bet amount (same as RFQ bet_amount)" },
          "total_payout": { "type": "number", "description": "Total payout if user wins (bet_amount * payout_odds)" },
          "mm_payout": { "type": "number", "description": "Market maker's risk (total_payout - total_cost)" },
          "valid_until": { "type": "string", "format": "date-time" },
          "status": { "$ref": "#/components/schemas/QuoteStatus" },
          "leg_prices": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "object",
              "properties": {
                "leg_id": { "type": "string" },
                "leg_odds": { "type": "number" }
              }
            }
          },
          "created_at": { "type": "string", "format": "date-time" },
          "updated_at": { "type": "string", "format": "date-time" }
        }
      },
      "CreateRFQRequest": {
        "type": "object",
        "required": ["legs", "bet_amount"],
        "properties": {
          "legs": {
            "type": "array",
            "minItems": 2,
            "maxItems": 5,
            "items": {
              "type": "object",
              "required": ["kalshi_market_ticker", "side"],
              "properties": {
                "kalshi_market_ticker": { "type": "string", "description": "Kalshi market ticker" },
                "side": { "$ref": "#/components/schemas/Side" }
              }
            },
            "description": "Parlay legs (2-5 required)"
          },
          "bet_amount": {
            "type": "number",
            "minimum": 1,
            "maximum": 10000,
            "description": "Bet amount in USDC"
          },
          "expires_in_seconds": {
            "type": "integer",
            "minimum": 60,
            "maximum": 3600,
            "default": 300,
            "description": "RFQ expiration time in seconds"
          }
        }
      },
      "CreateQuoteRequest": {
        "type": "object",
        "required": ["rfq_id", "payout_odds"],
        "properties": {
          "rfq_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the RFQ to quote"
          },
          "payout_odds": {
            "type": "number",
            "minimum": 1.01,
            "maximum": 1000,
            "description": "Payout multiplier (e.g., 4.0 means 4x return)"
          },
          "valid_for_seconds": {
            "type": "integer",
            "default": 60,
            "description": "Quote validity duration in seconds"
          },
          "leg_prices": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "object",
              "required": ["leg_id", "odds"],
              "properties": {
                "leg_id": { "type": "string", "description": "Leg UUID" },
                "odds": { "type": "number", "description": "Individual leg odds" }
              }
            },
            "description": "Optional per-leg price breakdown"
          }
        }
      },
      "AcceptQuoteResponse": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["accepted"] },
          "message": { "type": "string" },
          "confirmation_deadline": { "type": "string", "format": "date-time", "description": "MM must confirm within this deadline (60 seconds)" },
          "quote_id": { "type": "string", "format": "uuid" },
          "payout_odds": { "type": "number" },
          "total_cost": { "type": "number" },
          "total_payout": { "type": "number" }
        }
      },
      "ConfirmQuoteResponse": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["confirmed"] },
          "message": { "type": "string" },
          "execution_id": { "type": "string", "format": "uuid" },
          "quote_id": { "type": "string", "format": "uuid" },
          "rfq_id": { "type": "string", "format": "uuid" }
        }
      },
      "UserProfile": {
        "type": "object",
        "properties": {
          "username": { "type": "string" },
          "email": { "type": "string", "nullable": true },
          "wallet_address": { "type": "string", "nullable": true },
          "created_at": { "type": "string", "format": "date-time" }
        }
      },
      "CreatedApiKey": {
        "type": "object",
        "properties": {
          "key": { "type": "string", "description": "Full API key (only shown once)" },
          "key_prefix": { "type": "string" },
          "name": { "type": "string", "nullable": true },
          "created_at": { "type": "string", "format": "date-time" },
          "expires_at": { "type": "string", "format": "date-time", "nullable": true },
          "message": { "type": "string" }
        }
      },
      "ApiKeyInfo": {
        "type": "object",
        "properties": {
          "key_prefix": { "type": "string" },
          "name": { "type": "string", "nullable": true },
          "status": { "type": "string", "enum": ["active", "revoked", "expired"] },
          "created_at": { "type": "string", "format": "date-time" },
          "expires_at": { "type": "string", "format": "date-time", "nullable": true },
          "last_used_at": { "type": "string", "format": "date-time", "nullable": true },
          "request_count": { "type": "integer" }
        }
      },
      "AdminCreatedApiKey": {
        "type": "object",
        "properties": {
          "key": { "type": "string", "description": "Full API key (only shown once)" },
          "key_prefix": { "type": "string" },
          "entity_type": { "type": "string" },
          "entity_id": { "type": "string" },
          "name": { "type": "string", "nullable": true },
          "expires_at": { "type": "string", "format": "date-time", "nullable": true },
          "created_at": { "type": "string", "format": "date-time" },
          "message": { "type": "string" }
        }
      },
      "AdminApiKeyInfo": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "key_prefix": { "type": "string" },
          "entity_type": { "type": "string" },
          "entity_id": { "type": "string" },
          "name": { "type": "string", "nullable": true },
          "status": { "type": "string", "enum": ["active", "revoked", "expired"] },
          "created_at": { "type": "string", "format": "date-time" },
          "expires_at": { "type": "string", "format": "date-time", "nullable": true },
          "last_used_at": { "type": "string", "format": "date-time", "nullable": true },
          "request_count": { "type": "integer" },
          "revoked_at": { "type": "string", "format": "date-time", "nullable": true },
          "revoked_reason": { "type": "string", "nullable": true }
        }
      },
      "WalletBalances": {
        "type": "object",
        "properties": {
          "address": { "type": "string", "description": "Solana wallet address" },
          "sol_balance": { "type": "number", "description": "SOL balance" },
          "usdc_balance": { "type": "number", "description": "USDC balance" }
        }
      },
      "CachedMarket": {
        "type": "object",
        "properties": {
          "ticker": { "type": "string" },
          "event_ticker": { "type": "string" },
          "series_ticker": { "type": "string" },
          "series_title": { "type": "string" },
          "title": { "type": "string" },
          "subtitle": { "type": "string", "nullable": true },
          "category": { "type": "string" },
          "status": { "type": "string" },
          "volume": { "type": "integer" },
          "volume_24h": { "type": "integer" },
          "open_interest": { "type": "integer" },
          "yes_bid": { "type": "number" },
          "yes_ask": { "type": "number" },
          "no_bid": { "type": "number" },
          "no_ask": { "type": "number" },
          "last_price": { "type": "number" },
          "open_time": { "type": "string", "format": "date-time" },
          "close_time": { "type": "string", "format": "date-time" },
          "expiration_time": { "type": "string", "format": "date-time" },
          "kalshi_url": { "type": "string" },
          "synced_at": { "type": "string", "format": "date-time" }
        }
      },
      "HealthStatus": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["healthy", "unhealthy"] },
          "version": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "stats": {
            "type": "object",
            "description": "RFQ, quote, and escrow counts"
          },
          "market_cache": {
            "type": "object",
            "description": "Market cache statistics"
          },
          "sync": {
            "type": "object",
            "properties": {
              "running": { "type": "boolean" },
              "last_run": { "type": "object", "nullable": true }
            }
          },
          "websocket": {
            "type": "object",
            "description": "WebSocket connection statistics"
          }
        }
      },
      "SyncLog": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "series_ticker": { "type": "string" },
          "markets_synced": { "type": "integer" },
          "markets_removed": { "type": "integer" },
          "status": { "type": "string", "enum": ["success", "error"] },
          "error_message": { "type": "string", "nullable": true },
          "duration_ms": { "type": "integer" },
          "started_at": { "type": "string", "format": "date-time" },
          "completed_at": { "type": "string", "format": "date-time" }
        }
      },
      "ApiError": {
        "type": "object",
        "required": ["error"],
        "properties": {
          "error": {
            "type": "object",
            "required": ["code", "message"],
            "properties": {
              "code": { "type": "string", "description": "Machine-readable error code" },
              "message": { "type": "string", "description": "Human-readable error message" },
              "details": { "type": "object", "description": "Additional error context" }
            }
          }
        }
      }
    },
    "responses": {
      "Unauthorized": {
        "description": "Missing or invalid authentication",
        "content": {
          "application/json": {
            "schema": { "$ref": "#/components/schemas/ApiError" },
            "example": { "error": { "code": "UNAUTHORIZED", "message": "Missing or invalid authentication" } }
          }
        }
      },
      "Forbidden": {
        "description": "Authenticated but not authorized",
        "content": {
          "application/json": {
            "schema": { "$ref": "#/components/schemas/ApiError" },
            "example": { "error": { "code": "FORBIDDEN", "message": "Not authorized to access this resource" } }
          }
        }
      },
      "NotFound": {
        "description": "Resource not found",
        "content": {
          "application/json": {
            "schema": { "$ref": "#/components/schemas/ApiError" },
            "example": { "error": { "code": "NOT_FOUND", "message": "Resource not found" } }
          }
        }
      },
      "InternalError": {
        "description": "Internal server error",
        "content": {
          "application/json": {
            "schema": { "$ref": "#/components/schemas/ApiError" },
            "example": { "error": { "code": "INTERNAL_ERROR", "message": "Internal server error" } }
          }
        }
      }
    }
  }
}